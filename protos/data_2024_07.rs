// This file is generated by rust-protobuf 3.5.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `data_2024-07.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_0;

// @@protoc_insertion_point(message:SparseValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SparseValues {
    // message fields
    // @@protoc_insertion_point(field:SparseValues.indices)
    pub indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:SparseValues.values)
    pub values: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:SparseValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SparseValues {
    fn default() -> &'a SparseValues {
        <SparseValues as ::protobuf::Message>::default_instance()
    }
}

impl SparseValues {
    pub fn new() -> SparseValues {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "indices",
            |m: &SparseValues| { &m.indices },
            |m: &mut SparseValues| { &mut m.indices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &SparseValues| { &m.values },
            |m: &mut SparseValues| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SparseValues>(
            "SparseValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SparseValues {
    const NAME: &'static str = "SparseValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.indices)?;
                },
                8 => {
                    self.indices.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                21 => {
                    self.values.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint32_size(1, &self.indices);
        my_size += ::protobuf::rt::vec_packed_float_size(2, &self.values);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint32(1, &self.indices)?;
        os.write_repeated_packed_float(2, &self.values)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SparseValues {
        SparseValues::new()
    }

    fn clear(&mut self) {
        self.indices.clear();
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SparseValues {
        static instance: SparseValues = SparseValues {
            indices: ::std::vec::Vec::new(),
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SparseValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SparseValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SparseValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SparseValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Vector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Vector {
    // message fields
    // @@protoc_insertion_point(field:Vector.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:Vector.values)
    pub values: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:Vector.sparse_values)
    pub sparse_values: ::protobuf::MessageField<SparseValues>,
    // @@protoc_insertion_point(field:Vector.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:Vector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Vector {
    fn default() -> &'a Vector {
        <Vector as ::protobuf::Message>::default_instance()
    }
}

impl Vector {
    pub fn new() -> Vector {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Vector| { &m.id },
            |m: &mut Vector| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &Vector| { &m.values },
            |m: &mut Vector| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SparseValues>(
            "sparse_values",
            |m: &Vector| { &m.sparse_values },
            |m: &mut Vector| { &mut m.sparse_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &Vector| { &m.metadata },
            |m: &mut Vector| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Vector>(
            "Vector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Vector {
    const NAME: &'static str = "Vector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                21 => {
                    self.values.push(is.read_float()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_values)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::vec_packed_float_size(2, &self.values);
        if let Some(v) = self.sparse_values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_repeated_packed_float(2, &self.values)?;
        if let Some(v) = self.sparse_values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Vector {
        Vector::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.values.clear();
        self.sparse_values.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Vector {
        static instance: Vector = Vector {
            id: ::std::string::String::new(),
            values: ::std::vec::Vec::new(),
            sparse_values: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Vector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Vector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Vector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ScoredVector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScoredVector {
    // message fields
    // @@protoc_insertion_point(field:ScoredVector.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:ScoredVector.score)
    pub score: f32,
    // @@protoc_insertion_point(field:ScoredVector.values)
    pub values: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:ScoredVector.sparse_values)
    pub sparse_values: ::protobuf::MessageField<SparseValues>,
    // @@protoc_insertion_point(field:ScoredVector.metadata)
    pub metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:ScoredVector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScoredVector {
    fn default() -> &'a ScoredVector {
        <ScoredVector as ::protobuf::Message>::default_instance()
    }
}

impl ScoredVector {
    pub fn new() -> ScoredVector {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ScoredVector| { &m.id },
            |m: &mut ScoredVector| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "score",
            |m: &ScoredVector| { &m.score },
            |m: &mut ScoredVector| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ScoredVector| { &m.values },
            |m: &mut ScoredVector| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SparseValues>(
            "sparse_values",
            |m: &ScoredVector| { &m.sparse_values },
            |m: &mut ScoredVector| { &mut m.sparse_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "metadata",
            |m: &ScoredVector| { &m.metadata },
            |m: &mut ScoredVector| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScoredVector>(
            "ScoredVector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScoredVector {
    const NAME: &'static str = "ScoredVector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                21 => {
                    self.score = is.read_float()?;
                },
                26 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                29 => {
                    self.values.push(is.read_float()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_values)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.score != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::vec_packed_float_size(3, &self.values);
        if let Some(v) = self.sparse_values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.score != 0. {
            os.write_float(2, self.score)?;
        }
        os.write_repeated_packed_float(3, &self.values)?;
        if let Some(v) = self.sparse_values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScoredVector {
        ScoredVector::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.score = 0.;
        self.values.clear();
        self.sparse_values.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScoredVector {
        static instance: ScoredVector = ScoredVector {
            id: ::std::string::String::new(),
            score: 0.,
            values: ::std::vec::Vec::new(),
            sparse_values: ::protobuf::MessageField::none(),
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScoredVector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScoredVector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScoredVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoredVector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:RequestUnion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RequestUnion {
    // message oneof groups
    pub RequestUnionInner: ::std::option::Option<request_union::RequestUnionInner>,
    // special fields
    // @@protoc_insertion_point(special_field:RequestUnion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RequestUnion {
    fn default() -> &'a RequestUnion {
        <RequestUnion as ::protobuf::Message>::default_instance()
    }
}

impl RequestUnion {
    pub fn new() -> RequestUnion {
        ::std::default::Default::default()
    }

    // .UpsertRequest upsert = 1;

    pub fn upsert(&self) -> &UpsertRequest {
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(ref v)) => v,
            _ => <UpsertRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_upsert(&mut self) {
        self.RequestUnionInner = ::std::option::Option::None;
    }

    pub fn has_upsert(&self) -> bool {
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upsert(&mut self, v: UpsertRequest) {
        self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upsert(&mut self) -> &mut UpsertRequest {
        if let ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(_)) = self.RequestUnionInner {
        } else {
            self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(UpsertRequest::new()));
        }
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upsert(&mut self) -> UpsertRequest {
        if self.has_upsert() {
            match self.RequestUnionInner.take() {
                ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(v)) => v,
                _ => panic!(),
            }
        } else {
            UpsertRequest::new()
        }
    }

    // .DeleteRequest delete = 2;

    pub fn delete(&self) -> &DeleteRequest {
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Delete(ref v)) => v,
            _ => <DeleteRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete(&mut self) {
        self.RequestUnionInner = ::std::option::Option::None;
    }

    pub fn has_delete(&self) -> bool {
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Delete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete(&mut self, v: DeleteRequest) {
        self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Delete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete(&mut self) -> &mut DeleteRequest {
        if let ::std::option::Option::Some(request_union::RequestUnionInner::Delete(_)) = self.RequestUnionInner {
        } else {
            self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Delete(DeleteRequest::new()));
        }
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Delete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete(&mut self) -> DeleteRequest {
        if self.has_delete() {
            match self.RequestUnionInner.take() {
                ::std::option::Option::Some(request_union::RequestUnionInner::Delete(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteRequest::new()
        }
    }

    // .UpdateRequest update = 3;

    pub fn update(&self) -> &UpdateRequest {
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Update(ref v)) => v,
            _ => <UpdateRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_update(&mut self) {
        self.RequestUnionInner = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Update(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: UpdateRequest) {
        self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Update(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update(&mut self) -> &mut UpdateRequest {
        if let ::std::option::Option::Some(request_union::RequestUnionInner::Update(_)) = self.RequestUnionInner {
        } else {
            self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Update(UpdateRequest::new()));
        }
        match self.RequestUnionInner {
            ::std::option::Option::Some(request_union::RequestUnionInner::Update(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update(&mut self) -> UpdateRequest {
        if self.has_update() {
            match self.RequestUnionInner.take() {
                ::std::option::Option::Some(request_union::RequestUnionInner::Update(v)) => v,
                _ => panic!(),
            }
        } else {
            UpdateRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UpsertRequest>(
            "upsert",
            RequestUnion::has_upsert,
            RequestUnion::upsert,
            RequestUnion::mut_upsert,
            RequestUnion::set_upsert,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteRequest>(
            "delete",
            RequestUnion::has_delete,
            RequestUnion::delete,
            RequestUnion::mut_delete,
            RequestUnion::set_delete,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UpdateRequest>(
            "update",
            RequestUnion::has_update,
            RequestUnion::update,
            RequestUnion::mut_update,
            RequestUnion::set_update,
        ));
        oneofs.push(request_union::RequestUnionInner::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RequestUnion>(
            "RequestUnion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RequestUnion {
    const NAME: &'static str = "RequestUnion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Upsert(is.read_message()?));
                },
                18 => {
                    self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Delete(is.read_message()?));
                },
                26 => {
                    self.RequestUnionInner = ::std::option::Option::Some(request_union::RequestUnionInner::Update(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.RequestUnionInner {
            match v {
                &request_union::RequestUnionInner::Upsert(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request_union::RequestUnionInner::Delete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &request_union::RequestUnionInner::Update(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.RequestUnionInner {
            match v {
                &request_union::RequestUnionInner::Upsert(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &request_union::RequestUnionInner::Delete(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &request_union::RequestUnionInner::Update(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RequestUnion {
        RequestUnion::new()
    }

    fn clear(&mut self) {
        self.RequestUnionInner = ::std::option::Option::None;
        self.RequestUnionInner = ::std::option::Option::None;
        self.RequestUnionInner = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RequestUnion {
        static instance: RequestUnion = RequestUnion {
            RequestUnionInner: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RequestUnion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RequestUnion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RequestUnion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestUnion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `RequestUnion`
pub mod request_union {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:RequestUnion.RequestUnionInner)
    pub enum RequestUnionInner {
        // @@protoc_insertion_point(oneof_field:RequestUnion.upsert)
        Upsert(super::UpsertRequest),
        // @@protoc_insertion_point(oneof_field:RequestUnion.delete)
        Delete(super::DeleteRequest),
        // @@protoc_insertion_point(oneof_field:RequestUnion.update)
        Update(super::UpdateRequest),
    }

    impl ::protobuf::Oneof for RequestUnionInner {
    }

    impl ::protobuf::OneofFull for RequestUnionInner {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::RequestUnion as ::protobuf::MessageFull>::descriptor().oneof_by_name("RequestUnionInner").unwrap()).clone()
        }
    }

    impl RequestUnionInner {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<RequestUnionInner>("RequestUnionInner")
        }
    }
}

// @@protoc_insertion_point(message:UpsertRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpsertRequest {
    // message fields
    // @@protoc_insertion_point(field:UpsertRequest.vectors)
    pub vectors: ::std::vec::Vec<Vector>,
    // @@protoc_insertion_point(field:UpsertRequest.namespace)
    pub namespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:UpsertRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpsertRequest {
    fn default() -> &'a UpsertRequest {
        <UpsertRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpsertRequest {
    pub fn new() -> UpsertRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vectors",
            |m: &UpsertRequest| { &m.vectors },
            |m: &mut UpsertRequest| { &mut m.vectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &UpsertRequest| { &m.namespace },
            |m: &mut UpsertRequest| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpsertRequest>(
            "UpsertRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpsertRequest {
    const NAME: &'static str = "UpsertRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vectors.push(is.read_message()?);
                },
                18 => {
                    self.namespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.vectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.vectors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.namespace.is_empty() {
            os.write_string(2, &self.namespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpsertRequest {
        UpsertRequest::new()
    }

    fn clear(&mut self) {
        self.vectors.clear();
        self.namespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpsertRequest {
        static instance: UpsertRequest = UpsertRequest {
            vectors: ::std::vec::Vec::new(),
            namespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpsertRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpsertRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpsertRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpsertRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpsertResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpsertResponse {
    // message fields
    // @@protoc_insertion_point(field:UpsertResponse.upserted_count)
    pub upserted_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:UpsertResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpsertResponse {
    fn default() -> &'a UpsertResponse {
        <UpsertResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpsertResponse {
    pub fn new() -> UpsertResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upserted_count",
            |m: &UpsertResponse| { &m.upserted_count },
            |m: &mut UpsertResponse| { &mut m.upserted_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpsertResponse>(
            "UpsertResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpsertResponse {
    const NAME: &'static str = "UpsertResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upserted_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.upserted_count != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.upserted_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.upserted_count != 0 {
            os.write_uint32(1, self.upserted_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpsertResponse {
        UpsertResponse::new()
    }

    fn clear(&mut self) {
        self.upserted_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpsertResponse {
        static instance: UpsertResponse = UpsertResponse {
            upserted_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpsertResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpsertResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpsertResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpsertResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeleteRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteRequest {
    // message fields
    // @@protoc_insertion_point(field:DeleteRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:DeleteRequest.delete_all)
    pub delete_all: bool,
    // @@protoc_insertion_point(field:DeleteRequest.namespace)
    pub namespace: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteRequest.filter)
    pub filter: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteRequest {
    fn default() -> &'a DeleteRequest {
        <DeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequest {
    pub fn new() -> DeleteRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &DeleteRequest| { &m.ids },
            |m: &mut DeleteRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_all",
            |m: &DeleteRequest| { &m.delete_all },
            |m: &mut DeleteRequest| { &mut m.delete_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &DeleteRequest| { &m.namespace },
            |m: &mut DeleteRequest| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "filter",
            |m: &DeleteRequest| { &m.filter },
            |m: &mut DeleteRequest| { &mut m.filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteRequest>(
            "DeleteRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteRequest {
    const NAME: &'static str = "DeleteRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ids.push(is.read_string()?);
                },
                16 => {
                    self.delete_all = is.read_bool()?;
                },
                26 => {
                    self.namespace = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.delete_all != false {
            my_size += 1 + 1;
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.namespace);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        if self.delete_all != false {
            os.write_bool(2, self.delete_all)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(3, &self.namespace)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteRequest {
        DeleteRequest::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.delete_all = false;
        self.namespace.clear();
        self.filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteRequest {
        static instance: DeleteRequest = DeleteRequest {
            ids: ::std::vec::Vec::new(),
            delete_all: false,
            namespace: ::std::string::String::new(),
            filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeleteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteResponse {
    // special fields
    // @@protoc_insertion_point(special_field:DeleteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteResponse {
    fn default() -> &'a DeleteResponse {
        <DeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponse {
    pub fn new() -> DeleteResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteResponse>(
            "DeleteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteResponse {
    const NAME: &'static str = "DeleteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteResponse {
        DeleteResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteResponse {
        static instance: DeleteResponse = DeleteResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FetchRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FetchRequest {
    // message fields
    // @@protoc_insertion_point(field:FetchRequest.ids)
    pub ids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:FetchRequest.namespace)
    pub namespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:FetchRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FetchRequest {
    fn default() -> &'a FetchRequest {
        <FetchRequest as ::protobuf::Message>::default_instance()
    }
}

impl FetchRequest {
    pub fn new() -> FetchRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &FetchRequest| { &m.ids },
            |m: &mut FetchRequest| { &mut m.ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &FetchRequest| { &m.namespace },
            |m: &mut FetchRequest| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FetchRequest>(
            "FetchRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FetchRequest {
    const NAME: &'static str = "FetchRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ids.push(is.read_string()?);
                },
                18 => {
                    self.namespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            os.write_string(1, &v)?;
        };
        if !self.namespace.is_empty() {
            os.write_string(2, &self.namespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FetchRequest {
        FetchRequest::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.namespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FetchRequest {
        static instance: FetchRequest = FetchRequest {
            ids: ::std::vec::Vec::new(),
            namespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FetchRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FetchRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FetchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FetchRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FetchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FetchResponse {
    // message fields
    // @@protoc_insertion_point(field:FetchResponse.vectors)
    pub vectors: ::std::collections::HashMap<::std::string::String, Vector>,
    // @@protoc_insertion_point(field:FetchResponse.namespace)
    pub namespace: ::std::string::String,
    // @@protoc_insertion_point(field:FetchResponse.usage)
    pub usage: ::protobuf::MessageField<Usage>,
    // special fields
    // @@protoc_insertion_point(special_field:FetchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FetchResponse {
    fn default() -> &'a FetchResponse {
        <FetchResponse as ::protobuf::Message>::default_instance()
    }
}

impl FetchResponse {
    pub fn new() -> FetchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "vectors",
            |m: &FetchResponse| { &m.vectors },
            |m: &mut FetchResponse| { &mut m.vectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &FetchResponse| { &m.namespace },
            |m: &mut FetchResponse| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Usage>(
            "usage",
            |m: &FetchResponse| { &m.usage },
            |m: &mut FetchResponse| { &mut m.usage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FetchResponse>(
            "FetchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FetchResponse {
    const NAME: &'static str = "FetchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.vectors.insert(key, value);
                },
                18 => {
                    self.namespace = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.usage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.vectors {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace);
        }
        if let Some(v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.vectors {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.namespace.is_empty() {
            os.write_string(2, &self.namespace)?;
        }
        if let Some(v) = self.usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FetchResponse {
        FetchResponse::new()
    }

    fn clear(&mut self) {
        self.vectors.clear();
        self.namespace.clear();
        self.usage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FetchResponse {
        static instance: ::protobuf::rt::Lazy<FetchResponse> = ::protobuf::rt::Lazy::new();
        instance.get(FetchResponse::new)
    }
}

impl ::protobuf::MessageFull for FetchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FetchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FetchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FetchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListRequest {
    // message fields
    // @@protoc_insertion_point(field:ListRequest.prefix)
    pub prefix: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListRequest.limit)
    pub limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ListRequest.pagination_token)
    pub pagination_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ListRequest.namespace)
    pub namespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListRequest {
    fn default() -> &'a ListRequest {
        <ListRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListRequest {
    pub fn new() -> ListRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prefix",
            |m: &ListRequest| { &m.prefix },
            |m: &mut ListRequest| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limit",
            |m: &ListRequest| { &m.limit },
            |m: &mut ListRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pagination_token",
            |m: &ListRequest| { &m.pagination_token },
            |m: &mut ListRequest| { &mut m.pagination_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &ListRequest| { &m.namespace },
            |m: &mut ListRequest| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListRequest>(
            "ListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListRequest {
    const NAME: &'static str = "ListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prefix = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.pagination_token = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.namespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.pagination_token.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.prefix.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.limit {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.pagination_token.as_ref() {
            os.write_string(3, v)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(4, &self.namespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListRequest {
        ListRequest::new()
    }

    fn clear(&mut self) {
        self.prefix = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.pagination_token = ::std::option::Option::None;
        self.namespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListRequest {
        static instance: ListRequest = ListRequest {
            prefix: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            pagination_token: ::std::option::Option::None,
            namespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Pagination)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pagination {
    // message fields
    // @@protoc_insertion_point(field:Pagination.next)
    pub next: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Pagination.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pagination {
    fn default() -> &'a Pagination {
        <Pagination as ::protobuf::Message>::default_instance()
    }
}

impl Pagination {
    pub fn new() -> Pagination {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next",
            |m: &Pagination| { &m.next },
            |m: &mut Pagination| { &mut m.next },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pagination>(
            "Pagination",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pagination {
    const NAME: &'static str = "Pagination";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.next = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.next.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.next);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.next.is_empty() {
            os.write_string(1, &self.next)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pagination {
        Pagination::new()
    }

    fn clear(&mut self) {
        self.next.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pagination {
        static instance: Pagination = Pagination {
            next: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pagination {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Pagination").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pagination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pagination {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListItem {
    // message fields
    // @@protoc_insertion_point(field:ListItem.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ListItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListItem {
    fn default() -> &'a ListItem {
        <ListItem as ::protobuf::Message>::default_instance()
    }
}

impl ListItem {
    pub fn new() -> ListItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ListItem| { &m.id },
            |m: &mut ListItem| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListItem>(
            "ListItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListItem {
    const NAME: &'static str = "ListItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListItem {
        ListItem::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListItem {
        static instance: ListItem = ListItem {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListResponse {
    // message fields
    // @@protoc_insertion_point(field:ListResponse.vectors)
    pub vectors: ::std::vec::Vec<ListItem>,
    // @@protoc_insertion_point(field:ListResponse.pagination)
    pub pagination: ::protobuf::MessageField<Pagination>,
    // @@protoc_insertion_point(field:ListResponse.namespace)
    pub namespace: ::std::string::String,
    // @@protoc_insertion_point(field:ListResponse.usage)
    pub usage: ::protobuf::MessageField<Usage>,
    // special fields
    // @@protoc_insertion_point(special_field:ListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListResponse {
    fn default() -> &'a ListResponse {
        <ListResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListResponse {
    pub fn new() -> ListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vectors",
            |m: &ListResponse| { &m.vectors },
            |m: &mut ListResponse| { &mut m.vectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pagination>(
            "pagination",
            |m: &ListResponse| { &m.pagination },
            |m: &mut ListResponse| { &mut m.pagination },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &ListResponse| { &m.namespace },
            |m: &mut ListResponse| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Usage>(
            "usage",
            |m: &ListResponse| { &m.usage },
            |m: &mut ListResponse| { &mut m.usage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListResponse>(
            "ListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListResponse {
    const NAME: &'static str = "ListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.vectors.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pagination)?;
                },
                26 => {
                    self.namespace = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.usage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.vectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pagination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.namespace);
        }
        if let Some(v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.vectors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.pagination.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(3, &self.namespace)?;
        }
        if let Some(v) = self.usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListResponse {
        ListResponse::new()
    }

    fn clear(&mut self) {
        self.vectors.clear();
        self.pagination.clear();
        self.namespace.clear();
        self.usage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListResponse {
        static instance: ListResponse = ListResponse {
            vectors: ::std::vec::Vec::new(),
            pagination: ::protobuf::MessageField::none(),
            namespace: ::std::string::String::new(),
            usage: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:QueryVector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryVector {
    // message fields
    // @@protoc_insertion_point(field:QueryVector.values)
    pub values: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:QueryVector.sparse_values)
    pub sparse_values: ::protobuf::MessageField<SparseValues>,
    // @@protoc_insertion_point(field:QueryVector.top_k)
    pub top_k: u32,
    // @@protoc_insertion_point(field:QueryVector.namespace)
    pub namespace: ::std::string::String,
    // @@protoc_insertion_point(field:QueryVector.filter)
    pub filter: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:QueryVector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryVector {
    fn default() -> &'a QueryVector {
        <QueryVector as ::protobuf::Message>::default_instance()
    }
}

impl QueryVector {
    pub fn new() -> QueryVector {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &QueryVector| { &m.values },
            |m: &mut QueryVector| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SparseValues>(
            "sparse_values",
            |m: &QueryVector| { &m.sparse_values },
            |m: &mut QueryVector| { &mut m.sparse_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top_k",
            |m: &QueryVector| { &m.top_k },
            |m: &mut QueryVector| { &mut m.top_k },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &QueryVector| { &m.namespace },
            |m: &mut QueryVector| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "filter",
            |m: &QueryVector| { &m.filter },
            |m: &mut QueryVector| { &mut m.filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryVector>(
            "QueryVector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryVector {
    const NAME: &'static str = "QueryVector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                13 => {
                    self.values.push(is.read_float()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_values)?;
                },
                16 => {
                    self.top_k = is.read_uint32()?;
                },
                26 => {
                    self.namespace = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_float_size(1, &self.values);
        if let Some(v) = self.sparse_values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.top_k != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.top_k);
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.namespace);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_float(1, &self.values)?;
        if let Some(v) = self.sparse_values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.top_k != 0 {
            os.write_uint32(2, self.top_k)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(3, &self.namespace)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryVector {
        QueryVector::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.sparse_values.clear();
        self.top_k = 0;
        self.namespace.clear();
        self.filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryVector {
        static instance: QueryVector = QueryVector {
            values: ::std::vec::Vec::new(),
            sparse_values: ::protobuf::MessageField::none(),
            top_k: 0,
            namespace: ::std::string::String::new(),
            filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryVector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryVector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryVector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:QueryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryRequest {
    // message fields
    // @@protoc_insertion_point(field:QueryRequest.namespace)
    pub namespace: ::std::string::String,
    // @@protoc_insertion_point(field:QueryRequest.top_k)
    pub top_k: u32,
    // @@protoc_insertion_point(field:QueryRequest.filter)
    pub filter: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:QueryRequest.include_values)
    pub include_values: bool,
    // @@protoc_insertion_point(field:QueryRequest.include_metadata)
    pub include_metadata: bool,
    // @@protoc_insertion_point(field:QueryRequest.queries)
    pub queries: ::std::vec::Vec<QueryVector>,
    // @@protoc_insertion_point(field:QueryRequest.vector)
    pub vector: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:QueryRequest.sparse_vector)
    pub sparse_vector: ::protobuf::MessageField<SparseValues>,
    // @@protoc_insertion_point(field:QueryRequest.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:QueryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryRequest {
    fn default() -> &'a QueryRequest {
        <QueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl QueryRequest {
    pub fn new() -> QueryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &QueryRequest| { &m.namespace },
            |m: &mut QueryRequest| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top_k",
            |m: &QueryRequest| { &m.top_k },
            |m: &mut QueryRequest| { &mut m.top_k },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "filter",
            |m: &QueryRequest| { &m.filter },
            |m: &mut QueryRequest| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_values",
            |m: &QueryRequest| { &m.include_values },
            |m: &mut QueryRequest| { &mut m.include_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_metadata",
            |m: &QueryRequest| { &m.include_metadata },
            |m: &mut QueryRequest| { &mut m.include_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queries",
            |m: &QueryRequest| { &m.queries },
            |m: &mut QueryRequest| { &mut m.queries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vector",
            |m: &QueryRequest| { &m.vector },
            |m: &mut QueryRequest| { &mut m.vector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SparseValues>(
            "sparse_vector",
            |m: &QueryRequest| { &m.sparse_vector },
            |m: &mut QueryRequest| { &mut m.sparse_vector },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &QueryRequest| { &m.id },
            |m: &mut QueryRequest| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryRequest>(
            "QueryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryRequest {
    const NAME: &'static str = "QueryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace = is.read_string()?;
                },
                16 => {
                    self.top_k = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                32 => {
                    self.include_values = is.read_bool()?;
                },
                40 => {
                    self.include_metadata = is.read_bool()?;
                },
                50 => {
                    self.queries.push(is.read_message()?);
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.vector)?;
                },
                61 => {
                    self.vector.push(is.read_float()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_vector)?;
                },
                66 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace);
        }
        if self.top_k != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.top_k);
        }
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.include_values != false {
            my_size += 1 + 1;
        }
        if self.include_metadata != false {
            my_size += 1 + 1;
        }
        for value in &self.queries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::vec_packed_float_size(7, &self.vector);
        if let Some(v) = self.sparse_vector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.namespace.is_empty() {
            os.write_string(1, &self.namespace)?;
        }
        if self.top_k != 0 {
            os.write_uint32(2, self.top_k)?;
        }
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.include_values != false {
            os.write_bool(4, self.include_values)?;
        }
        if self.include_metadata != false {
            os.write_bool(5, self.include_metadata)?;
        }
        for v in &self.queries {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_repeated_packed_float(7, &self.vector)?;
        if let Some(v) = self.sparse_vector.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.id.is_empty() {
            os.write_string(8, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryRequest {
        QueryRequest::new()
    }

    fn clear(&mut self) {
        self.namespace.clear();
        self.top_k = 0;
        self.filter.clear();
        self.include_values = false;
        self.include_metadata = false;
        self.queries.clear();
        self.vector.clear();
        self.sparse_vector.clear();
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryRequest {
        static instance: QueryRequest = QueryRequest {
            namespace: ::std::string::String::new(),
            top_k: 0,
            filter: ::protobuf::MessageField::none(),
            include_values: false,
            include_metadata: false,
            queries: ::std::vec::Vec::new(),
            vector: ::std::vec::Vec::new(),
            sparse_vector: ::protobuf::MessageField::none(),
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SingleQueryResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SingleQueryResults {
    // message fields
    // @@protoc_insertion_point(field:SingleQueryResults.matches)
    pub matches: ::std::vec::Vec<ScoredVector>,
    // @@protoc_insertion_point(field:SingleQueryResults.namespace)
    pub namespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:SingleQueryResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SingleQueryResults {
    fn default() -> &'a SingleQueryResults {
        <SingleQueryResults as ::protobuf::Message>::default_instance()
    }
}

impl SingleQueryResults {
    pub fn new() -> SingleQueryResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &SingleQueryResults| { &m.matches },
            |m: &mut SingleQueryResults| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &SingleQueryResults| { &m.namespace },
            |m: &mut SingleQueryResults| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleQueryResults>(
            "SingleQueryResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SingleQueryResults {
    const NAME: &'static str = "SingleQueryResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                18 => {
                    self.namespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if !self.namespace.is_empty() {
            os.write_string(2, &self.namespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SingleQueryResults {
        SingleQueryResults::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.namespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SingleQueryResults {
        static instance: SingleQueryResults = SingleQueryResults {
            matches: ::std::vec::Vec::new(),
            namespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SingleQueryResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SingleQueryResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SingleQueryResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleQueryResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:QueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryResponse {
    // message fields
    // @@protoc_insertion_point(field:QueryResponse.results)
    pub results: ::std::vec::Vec<SingleQueryResults>,
    // @@protoc_insertion_point(field:QueryResponse.matches)
    pub matches: ::std::vec::Vec<ScoredVector>,
    // @@protoc_insertion_point(field:QueryResponse.namespace)
    pub namespace: ::std::string::String,
    // @@protoc_insertion_point(field:QueryResponse.usage)
    pub usage: ::protobuf::MessageField<Usage>,
    // special fields
    // @@protoc_insertion_point(special_field:QueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryResponse {
    fn default() -> &'a QueryResponse {
        <QueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &QueryResponse| { &m.results },
            |m: &mut QueryResponse| { &mut m.results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &QueryResponse| { &m.matches },
            |m: &mut QueryResponse| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &QueryResponse| { &m.namespace },
            |m: &mut QueryResponse| { &mut m.namespace },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Usage>(
            "usage",
            |m: &QueryResponse| { &m.usage },
            |m: &mut QueryResponse| { &mut m.usage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryResponse>(
            "QueryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryResponse {
    const NAME: &'static str = "QueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                18 => {
                    self.matches.push(is.read_message()?);
                },
                26 => {
                    self.namespace = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.usage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.namespace);
        }
        if let Some(v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.results {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.namespace.is_empty() {
            os.write_string(3, &self.namespace)?;
        }
        if let Some(v) = self.usage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.matches.clear();
        self.namespace.clear();
        self.usage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryResponse {
        static instance: QueryResponse = QueryResponse {
            results: ::std::vec::Vec::new(),
            matches: ::std::vec::Vec::new(),
            namespace: ::std::string::String::new(),
            usage: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Usage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Usage {
    // message fields
    // @@protoc_insertion_point(field:Usage.read_units)
    pub read_units: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:Usage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Usage {
    fn default() -> &'a Usage {
        <Usage as ::protobuf::Message>::default_instance()
    }
}

impl Usage {
    pub fn new() -> Usage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "read_units",
            |m: &Usage| { &m.read_units },
            |m: &mut Usage| { &mut m.read_units },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Usage>(
            "Usage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Usage {
    const NAME: &'static str = "Usage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.read_units = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.read_units {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.read_units {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Usage {
        Usage::new()
    }

    fn clear(&mut self) {
        self.read_units = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Usage {
        static instance: Usage = Usage {
            read_units: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Usage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Usage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Usage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Usage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpdateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateRequest {
    // message fields
    // @@protoc_insertion_point(field:UpdateRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateRequest.values)
    pub values: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:UpdateRequest.sparse_values)
    pub sparse_values: ::protobuf::MessageField<SparseValues>,
    // @@protoc_insertion_point(field:UpdateRequest.set_metadata)
    pub set_metadata: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // @@protoc_insertion_point(field:UpdateRequest.namespace)
    pub namespace: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:UpdateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateRequest {
    fn default() -> &'a UpdateRequest {
        <UpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRequest {
    pub fn new() -> UpdateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UpdateRequest| { &m.id },
            |m: &mut UpdateRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &UpdateRequest| { &m.values },
            |m: &mut UpdateRequest| { &mut m.values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SparseValues>(
            "sparse_values",
            |m: &UpdateRequest| { &m.sparse_values },
            |m: &mut UpdateRequest| { &mut m.sparse_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "set_metadata",
            |m: &UpdateRequest| { &m.set_metadata },
            |m: &mut UpdateRequest| { &mut m.set_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace",
            |m: &UpdateRequest| { &m.namespace },
            |m: &mut UpdateRequest| { &mut m.namespace },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateRequest>(
            "UpdateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateRequest {
    const NAME: &'static str = "UpdateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.values)?;
                },
                21 => {
                    self.values.push(is.read_float()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sparse_values)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_metadata)?;
                },
                34 => {
                    self.namespace = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::vec_packed_float_size(2, &self.values);
        if let Some(v) = self.sparse_values.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.namespace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.namespace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_repeated_packed_float(2, &self.values)?;
        if let Some(v) = self.sparse_values.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.set_metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.namespace.is_empty() {
            os.write_string(4, &self.namespace)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateRequest {
        UpdateRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.values.clear();
        self.sparse_values.clear();
        self.set_metadata.clear();
        self.namespace.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateRequest {
        static instance: UpdateRequest = UpdateRequest {
            id: ::std::string::String::new(),
            values: ::std::vec::Vec::new(),
            sparse_values: ::protobuf::MessageField::none(),
            set_metadata: ::protobuf::MessageField::none(),
            namespace: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpdateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateResponse {
    // special fields
    // @@protoc_insertion_point(special_field:UpdateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateResponse {
    fn default() -> &'a UpdateResponse {
        <UpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateResponse {
    pub fn new() -> UpdateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateResponse>(
            "UpdateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateResponse {
    const NAME: &'static str = "UpdateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateResponse {
        UpdateResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateResponse {
        static instance: UpdateResponse = UpdateResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DescribeIndexStatsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DescribeIndexStatsRequest {
    // message fields
    // @@protoc_insertion_point(field:DescribeIndexStatsRequest.filter)
    pub filter: ::protobuf::MessageField<::protobuf::well_known_types::struct_::Struct>,
    // special fields
    // @@protoc_insertion_point(special_field:DescribeIndexStatsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DescribeIndexStatsRequest {
    fn default() -> &'a DescribeIndexStatsRequest {
        <DescribeIndexStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DescribeIndexStatsRequest {
    pub fn new() -> DescribeIndexStatsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::struct_::Struct>(
            "filter",
            |m: &DescribeIndexStatsRequest| { &m.filter },
            |m: &mut DescribeIndexStatsRequest| { &mut m.filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DescribeIndexStatsRequest>(
            "DescribeIndexStatsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DescribeIndexStatsRequest {
    const NAME: &'static str = "DescribeIndexStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DescribeIndexStatsRequest {
        DescribeIndexStatsRequest::new()
    }

    fn clear(&mut self) {
        self.filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DescribeIndexStatsRequest {
        static instance: DescribeIndexStatsRequest = DescribeIndexStatsRequest {
            filter: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DescribeIndexStatsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DescribeIndexStatsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DescribeIndexStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescribeIndexStatsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NamespaceSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NamespaceSummary {
    // message fields
    // @@protoc_insertion_point(field:NamespaceSummary.vector_count)
    pub vector_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NamespaceSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NamespaceSummary {
    fn default() -> &'a NamespaceSummary {
        <NamespaceSummary as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceSummary {
    pub fn new() -> NamespaceSummary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vector_count",
            |m: &NamespaceSummary| { &m.vector_count },
            |m: &mut NamespaceSummary| { &mut m.vector_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NamespaceSummary>(
            "NamespaceSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NamespaceSummary {
    const NAME: &'static str = "NamespaceSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.vector_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.vector_count != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.vector_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.vector_count != 0 {
            os.write_uint32(1, self.vector_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NamespaceSummary {
        NamespaceSummary::new()
    }

    fn clear(&mut self) {
        self.vector_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NamespaceSummary {
        static instance: NamespaceSummary = NamespaceSummary {
            vector_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NamespaceSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NamespaceSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NamespaceSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DescribeIndexStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DescribeIndexStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:DescribeIndexStatsResponse.namespaces)
    pub namespaces: ::std::collections::HashMap<::std::string::String, NamespaceSummary>,
    // @@protoc_insertion_point(field:DescribeIndexStatsResponse.dimension)
    pub dimension: u32,
    // @@protoc_insertion_point(field:DescribeIndexStatsResponse.index_fullness)
    pub index_fullness: f32,
    // @@protoc_insertion_point(field:DescribeIndexStatsResponse.total_vector_count)
    pub total_vector_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DescribeIndexStatsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DescribeIndexStatsResponse {
    fn default() -> &'a DescribeIndexStatsResponse {
        <DescribeIndexStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DescribeIndexStatsResponse {
    pub fn new() -> DescribeIndexStatsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "namespaces",
            |m: &DescribeIndexStatsResponse| { &m.namespaces },
            |m: &mut DescribeIndexStatsResponse| { &mut m.namespaces },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dimension",
            |m: &DescribeIndexStatsResponse| { &m.dimension },
            |m: &mut DescribeIndexStatsResponse| { &mut m.dimension },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "index_fullness",
            |m: &DescribeIndexStatsResponse| { &m.index_fullness },
            |m: &mut DescribeIndexStatsResponse| { &mut m.index_fullness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_vector_count",
            |m: &DescribeIndexStatsResponse| { &m.total_vector_count },
            |m: &mut DescribeIndexStatsResponse| { &mut m.total_vector_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DescribeIndexStatsResponse>(
            "DescribeIndexStatsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DescribeIndexStatsResponse {
    const NAME: &'static str = "DescribeIndexStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.namespaces.insert(key, value);
                },
                16 => {
                    self.dimension = is.read_uint32()?;
                },
                29 => {
                    self.index_fullness = is.read_float()?;
                },
                32 => {
                    self.total_vector_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.namespaces {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.dimension != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.dimension);
        }
        if self.index_fullness != 0. {
            my_size += 1 + 4;
        }
        if self.total_vector_count != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.total_vector_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.namespaces {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.dimension != 0 {
            os.write_uint32(2, self.dimension)?;
        }
        if self.index_fullness != 0. {
            os.write_float(3, self.index_fullness)?;
        }
        if self.total_vector_count != 0 {
            os.write_uint32(4, self.total_vector_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DescribeIndexStatsResponse {
        DescribeIndexStatsResponse::new()
    }

    fn clear(&mut self) {
        self.namespaces.clear();
        self.dimension = 0;
        self.index_fullness = 0.;
        self.total_vector_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DescribeIndexStatsResponse {
        static instance: ::protobuf::rt::Lazy<DescribeIndexStatsResponse> = ::protobuf::rt::Lazy::new();
        instance.get(DescribeIndexStatsResponse::new)
    }
}

impl ::protobuf::MessageFull for DescribeIndexStatsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DescribeIndexStatsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DescribeIndexStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescribeIndexStatsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12data_2024-07.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1cgoog\
    le/api/annotations.proto\x1a\x1fgoogle/api/field_behavior.proto\"J\n\x0c\
    SparseValues\x12\x1d\n\x07indices\x18\x01\x20\x03(\rR\x07indicesB\x03\
    \xe0A\x02\x12\x1b\n\x06values\x18\x02\x20\x03(\x02R\x06valuesB\x03\xe0A\
    \x02\"\xa3\x01\n\x06Vector\x12\x13\n\x02id\x18\x01\x20\x01(\tR\x02idB\
    \x03\xe0A\x02\x12\x1b\n\x06values\x18\x02\x20\x03(\x02R\x06valuesB\x03\
    \xe0A\x02\x122\n\rsparse_values\x18\x04\x20\x01(\x0b2\r.SparseValuesR\
    \x0csparseValues\x123\n\x08metadata\x18\x03\x20\x01(\x0b2\x17.google.pro\
    tobuf.StructR\x08metadata\"\xba\x01\n\x0cScoredVector\x12\x13\n\x02id\
    \x18\x01\x20\x01(\tR\x02idB\x03\xe0A\x02\x12\x14\n\x05score\x18\x02\x20\
    \x01(\x02R\x05score\x12\x16\n\x06values\x18\x03\x20\x03(\x02R\x06values\
    \x122\n\rsparse_values\x18\x05\x20\x01(\x0b2\r.SparseValuesR\x0csparseVa\
    lues\x123\n\x08metadata\x18\x04\x20\x01(\x0b2\x17.google.protobuf.Struct\
    R\x08metadata\"\xa1\x01\n\x0cRequestUnion\x12(\n\x06upsert\x18\x01\x20\
    \x01(\x0b2\x0e.UpsertRequestH\0R\x06upsert\x12(\n\x06delete\x18\x02\x20\
    \x01(\x0b2\x0e.DeleteRequestH\0R\x06delete\x12(\n\x06update\x18\x03\x20\
    \x01(\x0b2\x0e.UpdateRequestH\0R\x06updateB\x13\n\x11RequestUnionInner\"\
    U\n\rUpsertRequest\x12&\n\x07vectors\x18\x01\x20\x03(\x0b2\x07.VectorR\
    \x07vectorsB\x03\xe0A\x02\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tname\
    space\"7\n\x0eUpsertResponse\x12%\n\x0eupserted_count\x18\x01\x20\x01(\r\
    R\rupsertedCount\"\x8f\x01\n\rDeleteRequest\x12\x10\n\x03ids\x18\x01\x20\
    \x03(\tR\x03ids\x12\x1d\n\ndelete_all\x18\x02\x20\x01(\x08R\tdeleteAll\
    \x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12/\n\x06filter\
    \x18\x04\x20\x01(\x0b2\x17.google.protobuf.StructR\x06filter\"\x10\n\x0e\
    DeleteResponse\"C\n\x0cFetchRequest\x12\x15\n\x03ids\x18\x01\x20\x03(\tR\
    \x03idsB\x03\xe0A\x02\x12\x1c\n\tnamespace\x18\x02\x20\x01(\tR\tnamespac\
    e\"\xd6\x01\n\rFetchResponse\x125\n\x07vectors\x18\x01\x20\x03(\x0b2\x1b\
    .FetchResponse.VectorsEntryR\x07vectors\x12\x1c\n\tnamespace\x18\x02\x20\
    \x01(\tR\tnamespace\x12!\n\x05usage\x18\x03\x20\x01(\x0b2\x06.UsageH\0R\
    \x05usage\x88\x01\x01\x1aC\n\x0cVectorsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x1d\n\x05value\x18\x02\x20\x01(\x0b2\x07.VectorR\
    \x05value:\x028\x01B\x08\n\x06_usage\"\xbd\x01\n\x0bListRequest\x12\x1b\
    \n\x06prefix\x18\x01\x20\x01(\tH\0R\x06prefix\x88\x01\x01\x12\x19\n\x05l\
    imit\x18\x02\x20\x01(\rH\x01R\x05limit\x88\x01\x01\x12.\n\x10pagination_\
    token\x18\x03\x20\x01(\tH\x02R\x0fpaginationToken\x88\x01\x01\x12\x1c\n\
    \tnamespace\x18\x04\x20\x01(\tR\tnamespaceB\t\n\x07_prefixB\x08\n\x06_li\
    mitB\x13\n\x11_pagination_token\"\x20\n\nPagination\x12\x12\n\x04next\
    \x18\x01\x20\x01(\tR\x04next\"\x1a\n\x08ListItem\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\"\xbf\x01\n\x0cListResponse\x12#\n\x07vectors\x18\x01\
    \x20\x03(\x0b2\t.ListItemR\x07vectors\x120\n\npagination\x18\x02\x20\x01\
    (\x0b2\x0b.PaginationH\0R\npagination\x88\x01\x01\x12\x1c\n\tnamespace\
    \x18\x03\x20\x01(\tR\tnamespace\x12!\n\x05usage\x18\x04\x20\x01(\x0b2\
    \x06.UsageH\x01R\x05usage\x88\x01\x01B\r\n\x0b_paginationB\x08\n\x06_usa\
    ge\"\xc2\x01\n\x0bQueryVector\x12\x1b\n\x06values\x18\x01\x20\x03(\x02R\
    \x06valuesB\x03\xe0A\x02\x122\n\rsparse_values\x18\x05\x20\x01(\x0b2\r.S\
    parseValuesR\x0csparseValues\x12\x13\n\x05top_k\x18\x02\x20\x01(\rR\x04t\
    opK\x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12/\n\x06filter\
    \x18\x04\x20\x01(\x0b2\x17.google.protobuf.StructR\x06filter\"\xd1\x02\n\
    \x0cQueryRequest\x12\x1c\n\tnamespace\x18\x01\x20\x01(\tR\tnamespace\x12\
    \x18\n\x05top_k\x18\x02\x20\x01(\rR\x04topKB\x03\xe0A\x02\x12/\n\x06filt\
    er\x18\x03\x20\x01(\x0b2\x17.google.protobuf.StructR\x06filter\x12%\n\
    \x0einclude_values\x18\x04\x20\x01(\x08R\rincludeValues\x12)\n\x10includ\
    e_metadata\x18\x05\x20\x01(\x08R\x0fincludeMetadata\x12*\n\x07queries\
    \x18\x06\x20\x03(\x0b2\x0c.QueryVectorR\x07queriesB\x02\x18\x01\x12\x16\
    \n\x06vector\x18\x07\x20\x03(\x02R\x06vector\x122\n\rsparse_vector\x18\t\
    \x20\x01(\x0b2\r.SparseValuesR\x0csparseVector\x12\x0e\n\x02id\x18\x08\
    \x20\x01(\tR\x02id\"[\n\x12SingleQueryResults\x12'\n\x07matches\x18\x01\
    \x20\x03(\x0b2\r.ScoredVectorR\x07matches\x12\x1c\n\tnamespace\x18\x02\
    \x20\x01(\tR\tnamespace\"\xb6\x01\n\rQueryResponse\x121\n\x07results\x18\
    \x01\x20\x03(\x0b2\x13.SingleQueryResultsR\x07resultsB\x02\x18\x01\x12'\
    \n\x07matches\x18\x02\x20\x03(\x0b2\r.ScoredVectorR\x07matches\x12\x1c\n\
    \tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12!\n\x05usage\x18\x04\x20\
    \x01(\x0b2\x06.UsageH\0R\x05usage\x88\x01\x01B\x08\n\x06_usage\":\n\x05U\
    sage\x12\"\n\nread_units\x18\x01\x20\x01(\rH\0R\treadUnits\x88\x01\x01B\
    \r\n\x0b_read_units\"\xca\x01\n\rUpdateRequest\x12\x13\n\x02id\x18\x01\
    \x20\x01(\tR\x02idB\x03\xe0A\x02\x12\x16\n\x06values\x18\x02\x20\x03(\
    \x02R\x06values\x122\n\rsparse_values\x18\x05\x20\x01(\x0b2\r.SparseValu\
    esR\x0csparseValues\x12:\n\x0cset_metadata\x18\x03\x20\x01(\x0b2\x17.goo\
    gle.protobuf.StructR\x0bsetMetadata\x12\x1c\n\tnamespace\x18\x04\x20\x01\
    (\tR\tnamespace\"\x10\n\x0eUpdateResponse\"L\n\x19DescribeIndexStatsRequ\
    est\x12/\n\x06filter\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\
    \x06filter\"5\n\x10NamespaceSummary\x12!\n\x0cvector_count\x18\x01\x20\
    \x01(\rR\x0bvectorCount\"\xae\x02\n\x1aDescribeIndexStatsResponse\x12K\n\
    \nnamespaces\x18\x01\x20\x03(\x0b2+.DescribeIndexStatsResponse.Namespace\
    sEntryR\nnamespaces\x12\x1c\n\tdimension\x18\x02\x20\x01(\rR\tdimension\
    \x12%\n\x0eindex_fullness\x18\x03\x20\x01(\x02R\rindexFullness\x12,\n\
    \x12total_vector_count\x18\x04\x20\x01(\rR\x10totalVectorCount\x1aP\n\
    \x0fNamespacesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12'\n\
    \x05value\x18\x02\x20\x01(\x0b2\x11.NamespaceSummaryR\x05value:\x028\x01\
    2\xb9\x04\n\rVectorService\x12E\n\x06Upsert\x12\x0e.UpsertRequest\x1a\
    \x0f.UpsertResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\"\x0f/vectors/upsert:\
    \x01*\x12X\n\x06Delete\x12\x0e.DeleteRequest\x1a\x0f.DeleteResponse\"-\
    \x82\xd3\xe4\x93\x02'\"\x0f/vectors/delete:\x01*Z\x11*\x0f/vectors/delet\
    e\x12>\n\x05Fetch\x12\r.FetchRequest\x1a\x0e.FetchResponse\"\x16\x82\xd3\
    \xe4\x93\x02\x10\x12\x0e/vectors/fetch\x12:\n\x04List\x12\x0c.ListReques\
    t\x1a\r.ListResponse\"\x15\x82\xd3\xe4\x93\x02\x0f\x12\r/vectors/list\
    \x129\n\x05Query\x12\r.QueryRequest\x1a\x0e.QueryResponse\"\x11\x82\xd3\
    \xe4\x93\x02\x0b\"\x06/query:\x01*\x12E\n\x06Update\x12\x0e.UpdateReques\
    t\x1a\x0f.UpdateResponse\"\x1a\x82\xd3\xe4\x93\x02\x14\"\x0f/vectors/upd\
    ate:\x01*\x12\x88\x01\n\x12DescribeIndexStats\x12\x1a.DescribeIndexStats\
    Request\x1a\x1b.DescribeIndexStatsResponse\"9\x82\xd3\xe4\x93\x023\"\x15\
    /describe_index_stats:\x01*Z\x17\x12\x15/describe_index_statsBK\n\x11io.\
    pinecone.protoP\x01Z4github.com/pinecone-io/go-pinecone/internal/gen/dat\
    ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(::protobuf::well_known_types::struct_::file_descriptor().clone());
            deps.push(super::annotations::file_descriptor().clone());
            deps.push(super::field_behavior::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(24);
            messages.push(SparseValues::generated_message_descriptor_data());
            messages.push(Vector::generated_message_descriptor_data());
            messages.push(ScoredVector::generated_message_descriptor_data());
            messages.push(RequestUnion::generated_message_descriptor_data());
            messages.push(UpsertRequest::generated_message_descriptor_data());
            messages.push(UpsertResponse::generated_message_descriptor_data());
            messages.push(DeleteRequest::generated_message_descriptor_data());
            messages.push(DeleteResponse::generated_message_descriptor_data());
            messages.push(FetchRequest::generated_message_descriptor_data());
            messages.push(FetchResponse::generated_message_descriptor_data());
            messages.push(ListRequest::generated_message_descriptor_data());
            messages.push(Pagination::generated_message_descriptor_data());
            messages.push(ListItem::generated_message_descriptor_data());
            messages.push(ListResponse::generated_message_descriptor_data());
            messages.push(QueryVector::generated_message_descriptor_data());
            messages.push(QueryRequest::generated_message_descriptor_data());
            messages.push(SingleQueryResults::generated_message_descriptor_data());
            messages.push(QueryResponse::generated_message_descriptor_data());
            messages.push(Usage::generated_message_descriptor_data());
            messages.push(UpdateRequest::generated_message_descriptor_data());
            messages.push(UpdateResponse::generated_message_descriptor_data());
            messages.push(DescribeIndexStatsRequest::generated_message_descriptor_data());
            messages.push(NamespaceSummary::generated_message_descriptor_data());
            messages.push(DescribeIndexStatsResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
